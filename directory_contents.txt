Filename: calculate_distances.cpp
#include "common.h"
#include "calculate_distances.h"

void create_distances() {
    // Check if the output file already exists
    std::ifstream checkFile("airport_distances.txt");
    if (checkFile.good()) {
        std::cout << "Distance list already exists." << std::endl;
        checkFile.close();
        return;  // Exit the function early if the file exists
    }

    std::ifstream infile("airport_coordinates_trimmed.txt");
    if (!infile.is_open()) {
        std::cerr << "Error opening airport_coordinates_trimmed.txt." << std::endl;
        return;
    }

    std::vector<Airport> airports;
    std::string line;
    while (std::getline(infile, line)) {
        std::istringstream iss(line);
        Airport airport;
        if (iss >> airport.tag >> airport.longitude >> airport.latitude) {
            airports.push_back(airport);
        }
    }
    infile.close();

    // Create and open the output file
    std::ofstream outfile("airport_distances.txt");

    int num_airports = airports.size();
    std::cout << "Starting distance calculations..." << std::endl;
    for (int i = 0; i < num_airports; ++i) {
        std::vector<std::pair<float, std::string>> distance_tag_pairs;
        for (int j = 0; j < num_airports; ++j) {
            float distance = haversine_distance(
                airports[i].latitude, airports[i].longitude,
                airports[j].latitude, airports[j].longitude);
            distance_tag_pairs.emplace_back(distance, airports[j].tag);
        }
        std::sort(distance_tag_pairs.begin(), distance_tag_pairs.end());

        // Write sorted distances to the output file
        outfile << airports[i].tag << ":\n";
        for (int k = 0; k < std::min(250, num_airports); ++k) {
            outfile << distance_tag_pairs[k].second << " " << distance_tag_pairs[k].first << "\n";
        }
        outfile << "END\n";

        // Output progress
        int percent_complete = static_cast<int>((i + 1) * 100.0 / num_airports);
        std::cout << "Progress: " << percent_complete << "% complete.\r";
        std::cout.flush();
    }
    outfile.close();
    std::cout << std::endl << "Distance calculations completed successfully." << std::endl;
}
----------------------------------------
Filename: calculate_distances.h
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cmath>
#include <string>
#include <algorithm>  // This includes std::sort
#include "common.h"

void create_distances();

----------------------------------------
Filename: common.cpp
#include "common.h"

float haversine_distance(float lat1, float lon1, float lat2, float lon2) {
    const float DEG_TO_RAD = 3.14159265358979323846f / 180.0f;
    lat1 *= DEG_TO_RAD;
    lon1 *= DEG_TO_RAD;
    lat2 *= DEG_TO_RAD;
    lon2 *= DEG_TO_RAD;

    float dlat = lat2 - lat1;
    float dlon = lon2 - lon1;
    float a = std::sin(dlat / 2.0f) * std::sin(dlat / 2.0f) +
              std::cos(lat1) * std::cos(lat2) * std::sin(dlon / 2.0f) * std::sin(dlon / 2.0f);
    float c = 2.0f * std::atan2(std::sqrt(a), std::sqrt(1.0f - a));
    return R * c;
}

void savePathToFile(const std::vector<std::string>& path, float total_distance, const std::string& filename) {
    std::ofstream outFile(filename);
    if (!outFile.is_open()) {
        std::cerr << "Error opening file " << filename << " for writing.\n";
        return;
    }
    for (const std::string& airport : path) {
        outFile << airport << "\n";
    }
    outFile << "Total distance: " << total_distance << " km\n";
    outFile.close();
    std::cout << "Path and total distance saved to " << filename << std::endl;
}

----------------------------------------
Filename: common.h
#ifndef COMMON_H
#define COMMON_H

#include <cmath>
#include <vector>
#include <string>
#include <fstream>
#include <iostream>

const float R = 6371.0f;
const std::string KDKX = "KDKX";
const float MAX_DISTANCE = 1000.0f;

struct Airport {
    std::string tag;
    float latitude;
    float longitude;
};

float haversine_distance(float lat1, float lon1, float lat2, float lon2);

void savePathToFile(const std::vector<std::string>& path, float total_distance, const std::string& filename);

#endif

----------------------------------------
Filename: depth_search.cpp
#include "depth_search.h"
#include "read_distances.h"
#include "common.h"
#include <iostream>
#include <vector>
#include <unordered_set>
#include <unordered_map>
#include <algorithm>
#include <queue>
#include <limits>
#include <set>
#include <chrono>

// Helper function to find the MST using Prim's algorithm with a Fibonacci heap
std::vector<std::pair<std::string, std::string>> constructMST(const std::vector<AirportData>& airports) {
    std::vector<std::pair<std::string, std::string>> mst;
    std::unordered_map<std::string, bool> inMST;
    std::priority_queue<std::tuple<float, std::string, std::string>, std::vector<std::tuple<float, std::string, std::string>>, std::greater<>> pq;
    std::string start = "KDKX";

    std::cout << "Constructing the Minimum Spanning Tree (MST)...\n";
    pq.push({0, start, ""});
    size_t count = 0;
    while (!pq.empty()) {
        auto [weight, u, parent] = pq.top();
        pq.pop();

        if (inMST[u]) continue;
        inMST[u] = true;

        if (!parent.empty()) {
            mst.push_back({u, parent});
        }

        for (const auto& airport : airports) {
            if (airport.tag == u) {
                for (const auto& edge : airport.distances) {
                    if (!inMST[edge.airport]) {
                        pq.push({edge.distance, edge.airport, u});
                    }
                }
                break;
            }
        }
        count++;
        if (count % 100 == 0) {
            std::cout << "Progress: " << count << " airports processed in MST construction...\n";
        }
    }
    std::cout << "MST construction completed with " << mst.size() << " edges.\n";
    return mst;
}

// Helper function to find odd degree vertices
std::vector<std::string> findOddDegreeVertices(const std::vector<std::pair<std::string, std::string>>& mst) {
    std::unordered_map<std::string, int> degreeCount;
    for (const auto& edge : mst) {
        degreeCount[edge.first]++;
        degreeCount[edge.second]++;
    }

    std::vector<std::string> oddDegreeVertices;
    for (const auto& [vertex, degree] : degreeCount) {
        if (degree % 2 == 1) {
            oddDegreeVertices.push_back(vertex);
        }
    }
    std::cout << "Found " << oddDegreeVertices.size() << " odd-degree vertices.\n";
    return oddDegreeVertices;
}

// Helper function to find minimum weight perfect matching using a greedy approach
std::vector<std::pair<std::string, std::string>> findMinimumWeightPerfectMatching(const std::vector<std::string>& oddVertices, const std::vector<AirportData>& airports) {
    std::vector<std::pair<std::string, std::string>> matching;
    std::set<std::string> unmatched(oddVertices.begin(), oddVertices.end());

    std::cout << "Finding minimum weight perfect matching...\n";
    size_t count = 0;
    while (!unmatched.empty()) {
        auto it1 = unmatched.begin();
        std::string u = *it1;
        unmatched.erase(it1);

        float minWeight = std::numeric_limits<float>::max();
        std::string minVertex;

        for (const auto& v : unmatched) {
            float weight = std::numeric_limits<float>::max();
            for (const auto& airport : airports) {
                if (airport.tag == u) {
                    for (const auto& edge : airport.distances) {
                        if (edge.airport == v) {
                            weight = edge.distance;
                            break;
                        }
                    }
                    break;
                }
            }
            if (weight < minWeight) {
                minWeight = weight;
                minVertex = v;
            }
        }

        unmatched.erase(minVertex);
        matching.push_back({u, minVertex});
        count++;
        if (count % 10 == 0) {
            std::cout << "Progress: " << count << " pairs matched...\n";
        }
    }

    std::cout << "Minimum weight perfect matching found with " << matching.size() << " edges.\n";
    return matching;
}

// Helper function to create Eulerian Circuit from MST and matching
std::vector<std::pair<std::string, std::string>> createEulerianCircuit(const std::vector<std::pair<std::string, std::string>>& mst, const std::vector<std::pair<std::string, std::string>>& matching) {
    std::vector<std::pair<std::string, std::string>> eulerianCircuit = mst;
    eulerianCircuit.insert(eulerianCircuit.end(), matching.begin(), matching.end());
    std::cout << "Eulerian circuit created with " << eulerianCircuit.size() << " edges.\n";
    return eulerianCircuit;
}

// Helper function to convert Eulerian Circuit to Hamiltonian Circuit
std::vector<std::string> createHamiltonianCircuit(const std::vector<std::pair<std::string, std::string>>& eulerianCircuit, const std::string& startAirport) {
    std::unordered_map<std::string, std::vector<std::string>> adjList;
    for (const auto& edge : eulerianCircuit) {
        adjList[edge.first].push_back(edge.second);
        adjList[edge.second].push_back(edge.first);
    }

    std::unordered_set<std::string> visited;
    std::vector<std::string> path;
    std::string current = startAirport;

    std::cout << "Converting Eulerian circuit to Hamiltonian circuit...\n";
    size_t count = 0;
    while (visited.size() < 110 && !current.empty()) {
        path.push_back(current);
        visited.insert(current);

        for (const auto& neighbor : adjList[current]) {
            if (visited.find(neighbor) == visited.end()) {
                current = neighbor;
                break;
            }
        }
        count++;
        if (count % 10 == 0) {
            std::cout << "Progress: " << count << " airports added to Hamiltonian circuit...\n";
        }
    }

    std::cout << "Hamiltonian circuit created with " << path.size() << " airports.\n";
    return path;
}

void depth_search(size_t maxDepth, size_t maxBreadth) {
    auto start = std::chrono::high_resolution_clock::now();
    std::cout << "Reading distances from file...\n";
    auto airports = readDistances("airport_distances.txt");
    if (airports.empty()) {
        std::cerr << "No airports data found. Exiting program.\n";
        return;
    }

    std::cout << "Constructing MST...\n";
    std::vector<std::pair<std::string, std::string>> mst = constructMST(airports);
    std::cout << "Finding odd degree vertices...\n";
    std::vector<std::string> oddDegreeVertices = findOddDegreeVertices(mst);
    std::cout << "Finding minimum weight perfect matching...\n";
    std::vector<std::pair<std::string, std::string>> matching = findMinimumWeightPerfectMatching(oddDegreeVertices, airports);
    std::cout << "Creating Eulerian circuit...\n";
    std::vector<std::pair<std::string, std::string>> eulerianCircuit = createEulerianCircuit(mst, matching);
    std::cout << "Creating Hamiltonian circuit...\n";
    std::vector<std::string> hamiltonianCircuit = createHamiltonianCircuit(eulerianCircuit, "KDKX");

    float total_distance = 0.0;
    for (size_t i = 1; i < hamiltonianCircuit.size(); ++i) {
        auto it = std::find_if(airports.begin(), airports.end(), [&](const AirportData& a) {
            return a.tag == hamiltonianCircuit[i - 1];
        });

        for (const auto& dist : it->distances) {
            if (dist.airport == hamiltonianCircuit[i]) {
                total_distance += dist.distance;
                break;
            }
        }
    }

    if (!hamiltonianCircuit.empty() && hamiltonianCircuit.size() == 110) {
        savePathToFile(hamiltonianCircuit, total_distance, "airport_list.txt");
        std::cout << "Path of 110 airports found and saved to airport_list.txt\n";
    } else {
        std::cerr << "Unable to generate a path of 110 airports.\n";
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> duration = end - start;
    std::cout << "Depth search completed in " << duration.count() << " seconds.\n";
}

----------------------------------------
Filename: depth_search.h
#ifndef DEPTH_SEARCH_H
#define DEPTH_SEARCH_H

#include <cstddef>

void depth_search(size_t maxDepth = 5, size_t maxBreadth = 10);

#endif // DEPTH_SEARCH_H

----------------------------------------
Filename: main.cpp
#include "trim_list.h"
#include "calculate_distances.h"
#include "read_distances.h"
#include "depth_search.h"
#include "nearest_neighbor.h"
#include <iostream>

int main() {
    std::cout << "Starting to create the trimmed list of airports...\n";
    if (create_trimmed_list()) {
        std::cout << "Trimmed list created successfully. Now calculating distances...\n";
        create_distances();
        std::cout << "Distances calculated and saved successfully.\n";

        // Prompt the user to select the algorithm
        int choice;
        std::cout << "Select the search algorithm:\n";
        std::cout << "1. Nearest Neighbor\n";
        std::cout << "2. Depth Search\n";
        std::cout << "Enter your choice (1 or 2): ";
        std::cin >> choice;

        if (choice == 1) {
            std::cout << "Starting nearest neighbor search...\n";
            nearest_neighbor_search();
            std::cout << "Nearest neighbor search completed. Check 'airport_list.txt' for the results.\n";
        } else if (choice == 2) {
            std::cout << "Starting depth search...\n";
            depth_search();
            std::cout << "Depth search completed. Check 'airport_list.txt' for the results.\n";
        } else {
            std::cout << "Invalid choice. Exiting program.\n";
        }
    } else {
        std::cout << "Failed to create the trimmed list. Check if the original data file 'airport_coordinates.txt' is present and correctly formatted.\n";
    }
    return 0;
}

----------------------------------------
Filename: Makefile
CXX = g++
CXXFLAGS = -Wall -g

# Target executable
TARGET = airport_program

# Source files
SRCS = main.cpp trim_list.cpp calculate_distances.cpp read_distances.cpp depth_search.cpp nearest_neighbor.cpp common.cpp

# Object files
OBJS = $(SRCS:.cpp=.o)

# Default target
all: $(TARGET)

$(TARGET): $(OBJS)
	$(CXX) $(CXXFLAGS) -o $(TARGET) $(OBJS)

# Compile source files into object files
%.o: %.cpp
	$(CXX) $(CXXFLAGS) -c $< -o $@

# Clean target
clean:
	rm -f $(TARGET) $(OBJS)

----------------------------------------
Filename: nearest_neighbor.cpp
#include "nearest_neighbor.h"
#include "read_distances.h"
#include "common.h"
#include <iostream>
#include <vector>
#include <unordered_set>
#include <algorithm>

void nearest_neighbor_search() {
    auto airports = readDistances("airport_distances.txt");
    if (airports.empty()) {
        std::cerr << "No airports data found. Exiting program.\n";
        return;
    }

    std::vector<std::string> path;
    std::unordered_set<std::string> visited;
    const std::string startAirport = "KDKX";
    path.push_back(startAirport);
    visited.insert(startAirport);

    std::string currentAirport = startAirport;
    float total_distance = 0.0;

    while (path.size() < 110 && !airports.empty()) {
        auto it = std::find_if(airports.begin(), airports.end(), [&](const AirportData& a) {
            return a.tag == currentAirport;
        });

        if (it == airports.end()) {
            std::cerr << "Error: Airport " << currentAirport << " not found in the data.\n";
            break;
        }

        bool foundNext = false;
        for (const auto& adj : it->distances) {
            if (visited.find(adj.airport) == visited.end()) {
                visited.insert(adj.airport);
                path.push_back(adj.airport);
                currentAirport = adj.airport;
                total_distance += adj.distance;
                foundNext = true;
                break;
            }
        }

        if (!foundNext) {
            std::cerr << "No unvisited neighbors found for airport " << currentAirport << ".\n";
            break;
        }
    }

    // Save the path to a file
    savePathToFile(path, total_distance, "airport_list.txt");
}

----------------------------------------
Filename: nearest_neighbor.h
#ifndef NEAREST_NEIGHBOR_H
#define NEAREST_NEIGHBOR_H

void nearest_neighbor_search();

#endif // NEAREST_NEIGHBOR_H

----------------------------------------
Filename: read_distances.cpp
#include "read_distances.h"
#include <fstream>
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <limits>
#include <algorithm>
#include <cctype>

// Utility function to trim whitespace from the end of a string
std::string rtrim(const std::string& s) {
    size_t end = s.find_last_not_of(" \t\n\r\f\v");
    return (end == std::string::npos) ? "" : s.substr(0, end + 1);
}

std::vector<AirportData> readDistances(const std::string& filename) {
    std::vector<AirportData> airports;
    std::ifstream file(filename);
    std::string line;

    std::cout << "Reading distances from file...\n";

    AirportData current_airport;
    bool reading_distances = false;

    while (getline(file, line)) {
        line = rtrim(line);
        if (line.empty()) continue;  // Skip empty lines

        if (line.back() == ':') {
            // Save the previous airport before starting a new one
            if (reading_distances) {
                airports.push_back(current_airport);
                // std::cout << "Saved airport: " << current_airport.tag << " with " << current_airport.distances.size() << " connections." << std::endl;
                reading_distances = false;
            }

            // Start a new airport
            current_airport.tag = line.substr(0, line.size() - 1);
            current_airport.distances.clear();
            // std::cout << "Starting new airport: " << current_airport.tag << std::endl;
            reading_distances = true;
        } else if (line == "END") {
            // End of current airport distances
            if (!current_airport.tag.empty()) {
                airports.push_back(current_airport);
                // std::cout << "Saved airport: " << current_airport.tag << " with " << current_airport.distances.size() << " connections." << std::endl;
                reading_distances = false;
            }
        } else {
            // Add connections to the current airport
            std::istringstream iss(line);
            std::string connectedAirport;
            float distance;
            iss >> connectedAirport >> distance;

            if (!current_airport.tag.empty() && !iss.fail()) {
                current_airport.distances.push_back({connectedAirport, distance});
            } else {
                std::cerr << "Parsing error or no current airport defined in line: " << line << std::endl;
            }
        }
    }

    // Make sure to add the last airport if the file didn't end with "END"
    if (reading_distances && !current_airport.tag.empty()) {
        airports.push_back(current_airport);
        // std::cout << "Saved airport: " << current_airport.tag << " with " << current_airport.distances.size() << " connections." << std::endl;
    }

    file.close();
    std::cout << "Distances loaded. Total airports: " << airports.size() << std::endl;
    return airports;
}

----------------------------------------
Filename: read_distances.h
#ifndef READ_DISTANCES_H
#define READ_DISTANCES_H

#include <vector>
#include <string>

struct Distance {
    std::string airport;
    float distance;
};

struct AirportData {
    std::string tag;
    std::vector<Distance> distances;
};

std::vector<AirportData> readDistances(const std::string& filename);

#endif // READ_DISTANCES_H

----------------------------------------
Filename: trim_list.cpp
#include "trim_list.h"
#include "common.h"
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>

bool create_trimmed_list() {
    std::ifstream checkFile("airport_coordinates_trimmed.txt");
    if (checkFile.good()) {
        std::cout << "Trimmed list already exists." << std::endl;
        checkFile.close();
        return true;  // Proceed to distance calculation
    }

    std::ifstream infile("airport_coordinates.txt");
    if (!infile.is_open()) {
        std::cerr << "Error opening airport_coordinates.txt." << std::endl;
        return false;
    }

    std::vector<Airport> airports;
    std::string line;
    Airport kdkx_airport;
    bool kdkx_found = false;

    std::cout << "Starting to read and process airport data..." << std::endl;
    while (std::getline(infile, line)) {
        std::istringstream iss(line);
        Airport airport;
        if (iss >> airport.tag >> airport.longitude >> airport.latitude) {
            airports.push_back(airport);
            if (airport.tag == KDKX) {
                kdkx_airport = airport;
                kdkx_found = true;
            }
        }
    }
    infile.close();

    if (!kdkx_found) {
        std::cerr << "KDKX not found in data." << std::endl;
        return false;
    }

    std::ofstream outfile("airport_coordinates_trimmed.txt");
    outfile << kdkx_airport.tag << " " << kdkx_airport.longitude << " " << kdkx_airport.latitude << "\n";
    int total_airports = airports.size();
    int processed_count = 0;
    for (const auto& airport : airports) {
        if (airport.tag != KDKX) {
            float dist = haversine_distance(kdkx_airport.latitude, kdkx_airport.longitude, airport.latitude, airport.longitude);
            if (dist <= MAX_DISTANCE) {
                outfile << airport.tag << " " << airport.longitude << " " << airport.latitude << "\n";
            }
        }
        processed_count++;
        int percent_complete = static_cast<int>((processed_count * 100.0) / total_airports);
        std::cout << "Processing progress: " << percent_complete << "%\r";
        std::cout.flush();
    }
    std::cout << std::endl << "Airport list trimmed and saved successfully." << std::endl;
    outfile.close();
    return true;
}

----------------------------------------
Filename: trim_list.h
#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <string>
#include "common.h"

bool create_trimmed_list();

----------------------------------------
